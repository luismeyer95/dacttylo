~07/01/2022~

-> Create event aggregator entity that groups:
    * User events (keystrokes)
    * Session events (p2p network) 
    * Tick events (immediate, delayed...)
-> Session and timer event stream initializations will each come with a client that allows
interacting with their respective task (ex: issue a session command or a delayed tick) which may
push new events to their stream
    * These clients will be passed down to state entities for them to manually trigger a main loop tick
    * This is useful for example for the WPM counter whose state updates are only triggered by a time interval
    * Pseudo-code for the WPM counter:
        task::spawn(loop {
            sleep(1).await;
            update_wpm_counter(); // will require Arc<Mutex<T>>
            client.send(tick).await; // only awaiting the send, not the tick
        })
-> How? 
    * Spawning a dedicated task for session events