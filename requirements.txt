High level requirements:
    -> write/delete characters on the screen
        -> polling key events fom the event bus
        -> mapping key events to editor actions
        -> apply actions to editor state
        -> render the editor state
            -> provide a highlighted editor state
                -> if state did not change and a hl state is cached
                   return the cache
                -> otherwise...
                    ST
                -> rehighlight from touched line synchronously
                    MT
                -> kick off background job for highlighting
                   the text from the first touched line (no cache = 0)
                -> wait for the first displayable chunk to be ready and
                   return it
                -> bg job keeps highlighting in the background
            -> configure the render using previous frame metadata
            -> process the highlighted state and render to screen buffer
            -> save metadata about the render (displayed lines)
    -> dynamic syntax highlighting
    -> scrolling/resizing handled properly

Networking:
    -> initiate typing race, either by hosting or joining a session
    -> a session would be identified by a handle/id provided on the command line
        -> joining a session
            -> user should provide his username along with a session id with the option 'join'
            -> connect to the session channel, notify the user's presence
            -> when host decides to start the session, context data is sent and session starts
            -> send/recv application specific payloads
        -> hosting a session
            -> user should provide his username along with a session id with the option 'host'
            -> checks are made to ensure the session is not already hosted
            -> listen for join notifications, send context data for each one
            -> session starts when host decides (ex: listen for enter key on stdin)
        -> each user should be made aware of every other user after joining and before the session starts
            -> host broadcasts the list of all users up to now after each join?
            -> every present user notifies the joining user?
        

